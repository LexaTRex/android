package de.culture4life.luca.testing.provider.opentestcheck;

import com.google.android.gms.common.util.Hex;

import android.util.Base64;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.nexenio.rxkeystore.RxKeyStore;
import com.nexenio.rxkeystore.provider.hash.RxHashProvider;
import com.nexenio.rxkeystore.provider.hash.Sha256HashProvider;

import de.culture4life.luca.registration.RegistrationData;
import de.culture4life.luca.testing.TestResultParsingException;
import de.culture4life.luca.testing.TestResultVerificationException;
import de.culture4life.luca.testing.provider.TestResultProvider;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;

import androidx.annotation.NonNull;
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;

import static de.culture4life.luca.testing.TestResultVerificationException.Reason.INVALID_SIGNATURE;
import static de.culture4life.luca.testing.TestResultVerificationException.Reason.NAME_MISMATCH;

public class OpenTestCheckTestResultProvider extends TestResultProvider<OpenTestCheckTestResult> {

    private static final String URL_PREFIX = "https://testverify.io/v1#";
    private static final RxHashProvider HASH_PROVIDER = new Sha256HashProvider(new RxKeyStore());
    protected static final String ENCODED_TICKET_IO_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqImfTl5rpFHeCM/cjAgeMS8mfhxGxO3+dss+1jidKRJ7ta2fOIQ6k1wPLtqh8U2HHIITXY8Atrlh81s9bSGeJIL9VY/QDeJgqwU147eDLqpO/iF4LvKa13bats+WzN2vXU9vPtk3WNRXh5SktbdMnmK49l20TgjzPac1ES3tv7MSExeF6Bq9zPrG47mUJW+Fm8AH7nID5kBYFosMcsRNVmY4PNYCYM7q17Cc/S/MjFZD+f4mzYLRnMbZs7IjLBGlrood21XHTNt1G6/1f4peA6EWCgKbCgbwdCIHl/wn/ktWOjxoAogX3oRcKOhhCcgt+7ReY8mj2exrTypmN3TscQIDAQAB";
    protected static final String ENCODED_SODA_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAu7TJ7bLhg3tvgXwnnTx8IFL80/qGDIuctJR/HN0EzooYooMJi0tauRvokbKOqZ40bPahOUMZheeaueKkzSEyfjqPAXOSNzBe9ltgHQcDWjKUuMIaTJW5w2nJncR5UAOFmuqY8aL5IInu/vVgTjP/mXqWN5JKiEGpA3R7UNn0RWFdU6HJ4qq1n52hyUNFF4bRTQHqkw3fnJEMTOqubo4StBX2GMO8F/pCn4UA8+nhzHbtvE1QE4R+ibxs2zbGwDFL5EFDdbqvLULeMfSys5pUDgx7z04oaSzh/MYvtApqOv3dxHi8HkBlCXNUMjUD6EWukcWn4IFHC9MAKzYq4JcfANNjka5ug5LUuL84GcITKqeesZzbSSUU3/OTRk4yri7QbbNKfbv3+E9rUpcQhVTVNdBo3jxqmCm25GjwmYWTLE9++UT4IiUid3Y6kAC+Xeiz2Q+9bXszj6tME1WrhKCAc6dvM6vM3neYul5xnI/K1CSq7lB8KDxCS1//7FT6EIDa4+UVSONkTrVzaVexQgt/fMO3c5TadjS8KN3Gml0DIhzahAXzp+CJ+0xgQqsTcoujRfnVCw2d3YLP6x8JKG4vPikYUhOJ1NEBuAJv1Ict1uFuIoClaw1TkoDeUU4rPcemSOb3JXRKZeIQrRGU9vOzNVfCViDYkiE3X/IbmedhTEUCAwEAAQ==";

    private RSAPublicKey ticketIoKey;
    private RSAPublicKey sodaKey;

    @Override
    public Single<Boolean> canParse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(JWT::decode)
                .map(decodedJWT -> true)
                .onErrorReturnItem(false);
    }

    @Override
    public Single<OpenTestCheckTestResult> parse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(OpenTestCheckTestResult::new)
                .onErrorResumeNext(throwable -> Single.error(new TestResultParsingException(throwable)));
    }

    @Override
    public Completable validate(@NonNull OpenTestCheckTestResult testResult, @NonNull RegistrationData registrationData) {
        return Completable.mergeArray(
                verifyJwt(testResult.getLucaTestResult().getEncodedData()),
                verifyNameHash(testResult.n, registrationData)
        );
    }

    private Completable verifyJwt(@NonNull String jwt) {
        return Maybe.mergeDelayError(getPublicKeys()
                .map(publicKey -> verifyJwt(jwt, publicKey)
                        .andThen(Maybe.just(publicKey))
                        .onErrorResumeWith(Maybe.empty()))
                .toFlowable(BackpressureStrategy.BUFFER))
                .firstOrError()
                .ignoreElement()
                .onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyJwt(@NonNull String jwt, @NonNull RSAPublicKey publicKey) {
        return Completable.fromAction(() -> {
            Algorithm algorithm = Algorithm.RSA256(publicKey, null);
            JWTVerifier verifier = JWT.require(algorithm).build();
            verifier.verify(jwt);
        }).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyNameHash(@NonNull String expectedNameHash, @NonNull RegistrationData registrationData) {
        return generateNameHash(registrationData)
                .flatMapCompletable(actualNameHash -> Completable.fromAction(() -> {
                    if (!actualNameHash.equals(expectedNameHash)) {
                        throw new IllegalArgumentException("Name hash mismatch");
                    }
                })).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(NAME_MISMATCH, throwable)));
    }

    private Single<String> generateNameHash(@NonNull RegistrationData registrationData) {
        return Single.fromCallable(() -> {
            String name = registrationData.getFirstName() + registrationData.getLastName();
            name = name.toUpperCase();
            name = name.replaceAll("[^\\x00-\\x7F]", "");
            name = name.replaceAll("/[^\\x41-\\x5A]/", "");
            return name.getBytes(StandardCharsets.US_ASCII);
        }).flatMap(HASH_PROVIDER::hash).map(Hex::bytesToStringLowercase);
    }

    private Single<String> getEncodedJwtWithoutUrl(@NonNull String encodedData) {
        return Single.fromCallable(() -> {
            if (encodedData.startsWith(URL_PREFIX)) {
                return encodedData.substring(URL_PREFIX.length());
            } else {
                return encodedData;
            }
        });
    }

    private Observable<RSAPublicKey> getPublicKeys() {
        return Single.merge(getTicketIoKey(), getSodaPublicKey())
                .toObservable();
    }

    private Single<RSAPublicKey> getTicketIoKey() {
        return Maybe.fromCallable(() -> ticketIoKey)
                .switchIfEmpty(decodePublicKey(ENCODED_TICKET_IO_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.ticketIoKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getSodaPublicKey() {
        return Maybe.fromCallable(() -> sodaKey)
                .switchIfEmpty(decodePublicKey(ENCODED_SODA_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.sodaKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> decodePublicKey(@NonNull String encodedPublicKey) {
        return Single.fromCallable(() -> {
            byte[] encoded = Base64.decode(encodedPublicKey, Base64.NO_WRAP);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
        });
    }

}
