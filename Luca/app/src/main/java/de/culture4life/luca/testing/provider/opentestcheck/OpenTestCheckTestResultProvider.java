package de.culture4life.luca.testing.provider.opentestcheck;

import com.google.android.gms.common.util.Hex;

import android.util.Base64;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.nexenio.rxkeystore.RxKeyStore;
import com.nexenio.rxkeystore.provider.hash.RxHashProvider;
import com.nexenio.rxkeystore.provider.hash.Sha256HashProvider;

import de.culture4life.luca.registration.RegistrationData;
import de.culture4life.luca.testing.TestResultParsingException;
import de.culture4life.luca.testing.TestResultVerificationException;
import de.culture4life.luca.testing.provider.TestResultProvider;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;

import androidx.annotation.NonNull;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;

import static de.culture4life.luca.testing.TestResultVerificationException.Reason.INVALID_SIGNATURE;
import static de.culture4life.luca.testing.TestResultVerificationException.Reason.NAME_MISMATCH;

public class OpenTestCheckTestResultProvider extends TestResultProvider<OpenTestCheckTestResult> {

    private static final String URL_PREFIX = "https://testverify.io/v1#";
    private static final RxHashProvider HASH_PROVIDER = new Sha256HashProvider(new RxKeyStore());
    protected static final String ENCODED_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqImfTl5rpFHeCM/cjAge\n" +
            "MS8mfhxGxO3+dss+1jidKRJ7ta2fOIQ6k1wPLtqh8U2HHIITXY8Atrlh81s9bSGe\n" +
            "JIL9VY/QDeJgqwU147eDLqpO/iF4LvKa13bats+WzN2vXU9vPtk3WNRXh5SktbdM\n" +
            "nmK49l20TgjzPac1ES3tv7MSExeF6Bq9zPrG47mUJW+Fm8AH7nID5kBYFosMcsRN\n" +
            "VmY4PNYCYM7q17Cc/S/MjFZD+f4mzYLRnMbZs7IjLBGlrood21XHTNt1G6/1f4pe\n" +
            "A6EWCgKbCgbwdCIHl/wn/ktWOjxoAogX3oRcKOhhCcgt+7ReY8mj2exrTypmN3Ts\n" +
            "cQIDAQAB\n";

    private RSAPublicKey publicKey;

    @Override
    public Single<Boolean> canParse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(JWT::decode)
                .map(decodedJWT -> true)
                .onErrorReturnItem(false);
    }

    @Override
    public Single<OpenTestCheckTestResult> parse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(OpenTestCheckTestResult::new)
                .onErrorResumeNext(throwable -> Single.error(new TestResultParsingException(throwable)));
    }

    @Override
    public Completable validate(@NonNull OpenTestCheckTestResult testResult, @NonNull RegistrationData registrationData) {
        return Completable.mergeArray(
                verifyJwt(testResult.getLucaTestResult().getEncodedData()),
                verifyNameHash(testResult.n, registrationData)
        );
    }

    private Single<RSAPublicKey> getPublicKey() {
        return Maybe.fromCallable(() -> publicKey)
                .switchIfEmpty(Single.fromCallable(() -> {
                    byte[] encoded = Base64.decode(ENCODED_PUBLIC_KEY, Base64.NO_WRAP);
                    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
                    return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
                }).doOnSuccess(decodedPublicKey -> this.publicKey = decodedPublicKey));
    }

    private Completable verifyJwt(@NonNull String jwt) {
        return getPublicKey()
                .flatMapCompletable(rsaPublicKey -> Completable.fromAction(() -> {
                    Algorithm algorithm = Algorithm.RSA256(publicKey, null);
                    JWTVerifier verifier = JWT.require(algorithm).build();
                    verifier.verify(jwt);
                })).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyNameHash(@NonNull String expectedNameHash, @NonNull RegistrationData registrationData) {
        return generateNameHash(registrationData)
                .flatMapCompletable(actualNameHash -> Completable.fromAction(() -> {
                    if (!actualNameHash.equals(expectedNameHash)) {
                        throw new IllegalArgumentException("Name hash mismatch");
                    }
                })).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(NAME_MISMATCH, throwable)));
    }

    private Single<String> generateNameHash(@NonNull RegistrationData registrationData) {
        return Single.fromCallable(() -> {
            String name = registrationData.getFirstName() + registrationData.getLastName();
            name = name.toUpperCase();
            name = name.replaceAll("/[^\\x41-\\x5A]/", "");
            return name.getBytes(StandardCharsets.US_ASCII);
        }).flatMap(HASH_PROVIDER::hash).map(Hex::bytesToStringLowercase);
    }

    private Single<String> getEncodedJwtWithoutUrl(@NonNull String encodedData) {
        return Single.fromCallable(() -> {
            if (encodedData.startsWith(URL_PREFIX)) {
                return encodedData.substring(URL_PREFIX.length());
            } else {
                return encodedData;
            }
        });
    }

}
